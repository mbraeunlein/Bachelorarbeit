\newpage
\section{Eigene Software}
\label{Eigene_Software}
Trotz der verwendeten Software ist im Rahmen dieser Arbeit auch eigene Software entwickelt worden. Die Software ist komplett in Java geschrieben. Hier möchte ich kurz auf die einzelnen Komponenten und deren Funktionen eingehen.\\
Zuerst wurde eine Klasse entwickelt, die es ermöglicht, Sudokus in einem definierten Format \ref{Sudoku_Format} einzulesen und in die von Hodoku verwendeten \textit{Sudoku2} Objekte zu parsen. Die nächste, wichtige und selbst entwickelte Funktionalität ist 
das extrahieren eines Featurevectors. Das grobe Vorgehen ist in \ref{Aufbau} beschrieben, die Implementiereung findet sich in der Klasse \textit{/src/FeatureVectorExtractor.java}. Diese nimmt ein Objekt von \textit{Sudoku2} entgegen und liefert ein FeatureVector Objekt zurück, indem sie das Sudoku schrittweise und mit Hilfe von Hodoku löst. Eine weitere, selbst entwickelte Klasse schreibt eine Menge von Featurevectoren in eine .arff Datei, die von Weka verarbeitet werden kann. Natürlich wäre es möglich gewesen, die Featurevectoren auch direkt an den Klassifizierer zu übergeben, durch das schreiben in eine .arff Datei bleibt dem Nutzer die Möglichkeit erhalten, die Daten später mit Weka genauer zu analysieren.\\
In \textit{src/analyze/Analyzer.java} wurden die Modi implementiert, die benötigt werden, um Sudokus zu analysieren. Hier wird die Weka library verwendet.\\
Eine Besonderheit der Software finder sich in der Klasse \textit{/src/FeatureVectorExtractor.java}. Hier würde als letzte mögliche Methode \textit{Backtracking} \ref{Backtracking} angewendet werden. Diese löst jedes Sudoku vollständig durch \textit{trial and error}. Es gibt kein Sudoku, das nicht durch \textit{Backtracking} gelöst werden kann. Da diese Methode allerdings das ganze Sudoku auf einmal löst, wird sie nur angewendet, wenn keine andere Methode funktioniert. Für die Klassifikation ist nur relevant, wie viele Zahlen mit \textit{Backtracking} ermittelt wurden. Das kann man auch schon vor dem Anwenden der Methode errechnen, da sie für alle offenen Felder die entsprechenden Zahlen finden wird. Dies kann man ohne Ausführen der Methode in den Featurevector eintragen, was zu einer deutlichen Verbesserung der Laufzeit führt.

